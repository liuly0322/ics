# 数据表示：补码与浮点数

## 补码 (2's complement)

### 编码

编码是给定位数的二进制串到数字的映射，可以看成一个函数 $f$

例如，$n$ 位的原码是一种编码：

$$f(\overline{a_1a_2a_3 ... a_{n}}) = \sum\limits_{i=1}^{n}a_i2^{n-i}$$

2 位的补码也是一种编码：

$$
f(x)=
\begin{cases}
0, & x=\overline{00},\\
1, & x=\overline{01},\\
-2, & x=\overline{10},\\
-1, & x=\overline{11}
\end{cases}
$$

编码 $f$ 的值域是该编码能表示的数的集合。例如，$n$ 位原码的值域是 $[0, 2^n-1]$

### 负数

原码只能表示正数。那么，一个兼容负数的编码 $f$ 该如何设计呢？

从计算机硬件的角度考量，无符号数（原码）的加法器和乘法器是必须的（我们的 LC-3 虽然没有乘法指令，但你也可以自己补充）

我们希望 $f$ 编码下，数字的加法，乘法也能兼容无符号数的加法，乘法

- 减法即加上相反数，因此 $f$ 编码只需要考虑加法，不需要额外考虑减法

我们给出 $f$ 应该满足的性质：

1. 该编码下数字的加法应该等于编码之和（复用无符号数的加法器）

$$f(a) + f(b) \equiv f(a+b) \mod 2^n$$

2. 该编码下数字的乘法也应该等于编码的乘法（复用无符号数的乘法器）

$$f(a)f(b) \equiv f(ab) \mod 2^n$$

3. 该编码应该能表示尽可能多的数字，我们假设 $f$ 是一一映射（即存在反函数 $f^{-1}$ ）

4. 该编码值域应该是连续的 $[-p, q]$ ，其中 $p, q > 0$ ，结合性质三可知 $p+q-1= 2^n$

#### 解法一：

性质二代入 $b = \overline{00...0}$，得

$$f(a)f(\overline{00...0}) \equiv f(\overline{00...0}) \mod 2^n$$

等式左侧 $f(a)$ 是一个变量，等式右侧 $f(\overline{00...0})$ 是一个常数，得：

$$f(\overline{00...0}) = 0$$

性质二代入 $b = \overline{00...1}$，得

$$f(a)f(\overline{00...1}) \equiv f(a) \mod 2^n$$

同理，得：

$$f(\overline{00...1}) = 1$$

再解 $f(a)=-1$:

在性质一中令 $f(a)=-1$，并取 $b = \overline{00...1}$

$$-1 + 1 \equiv f(a+\overline{00...1}) \mod 2^n$$
$$f(a+\overline{00...1}) \equiv 0 \mod 2^n$$

同时取反函数

$$a+\overline{00...1} \equiv \overline{00...0} \mod 2^n$$

$$a=\overline{11...1}$$

已知 $f(\overline{11...1}) = -1$，自然有 $-2 = -1 + -1 = f(\overline{11...1}+\overline{11...1}) = f(\overline{11...0})$

同理：

$$-n = -n + 1 + (-1) = f(f^{-1}(-n+1) + \overline{11...1})$$

得到了所有负数 $[-p, -1]$ 对应的补码表示

而：

$$n+1 = f(f^{-1}(n) + \overline{00...1})$$

得到了所有正数 $[1, q]$ 的补码表示

事实上，$p, q$ 只要满足 $p+q-1=2^n$ ，它们具体的值是可以任意选取的：

对于一个二进制串 $x = \overline{a_1a_2a_3 ... a_{n}}$：

- 若 $f(x) \in [1, q]$，$f(x) = \sum\limits_{i=1}^{n}a_i2^{n-i}$
- 若 $f(x) \in [-p, -1]$，$f(x) = -(2^{n} - \sum\limits_{i=1}^{n}a_i2^{n-i}) = \sum\limits_{i=1}^{n}a_i2^{n-i} - 2^{n}$

注意到二者取值恰好相差 $2^{n}$，而性质一和二都是模 $2^n$ 而言的，自然满足

#### 解法二：

事实上，无符号数（原码）的加法器和乘法器在考虑溢出的情况下，一个更合适的类比是模 $2^n$ 的同余等价类的加法器和乘法器

例如，在 4 位原码下，$\overline{1101} + \overline{0100} = \overline{0001}$ ，通常而言，这会被认为是溢出

但如果按照模 $2^n$ 的同余等价类的观点来看，$[13] + [4] = [17] = [1]$ ，$17$ 和 $1$ 不过是该等价类的两个代表元，在这个意义上，性质一和性质二的同余符号就不再需要了

$$f(a) + f(b) = f(a+b)$$

$$f(a)f(b) = f(ab)$$

从代数结构的角度，这说明二进制串的结构是一个环，且与模 $2^n$ 的同余等价类同态

不太严谨地，我们直接得出结论：

$$f(x) = [\sum\limits_{i=1}^{n}a_i2^{n-i}] =
\begin{cases}
\sum\limits_{i=1}^{n}a_i2^{n-i},\\
\sum\limits_{i=1}^{n}a_i2^{n-i} - 2^n
\end{cases}$$

具体 $f(x)$ 的取值由值域给定

方便起见，通常把 $1$ 开头的二进制串用来表示负数，值域 $[-2^{n-1}, 2^{n-1}-1]$

### 负数的补码表示：

在明白了补码的结构之后，可以得到负数的补码表示与其相反数的补码表示的关系：

对 $a>0$ :

$$0 = f(a+(-a)) = f(f^{-1}(a) + f^{-1}(-a))$$

$$\overline{00...0} = f^{-1}(a) + f^{-1}(-a)$$

$$\overline{11...1} + \overline{00...1} = f^{-1}(a) + f^{-1}(-a)$$

$$f^{-1}(-a) = (\overline{11...1} - f^{-1}(a)) + \overline{00...1}$$

$$f^{-1}(-a) = \textasciitilde f^{-1}(a) + \overline{00...1}$$

得到 $-a$ 的补码表示就是 $a$ 的补码表示取反再加一